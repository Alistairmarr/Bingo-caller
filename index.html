<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bingo Caller</title>
  <style>
    :root {
      /* Width of the left (number) column scales with viewport height */
      --numCol: 40vmin;
      /* Default cell size – recalculated in JavaScript to fill the grid */
      --cell: 40px;
      /* Gap between grid cells */
      --gap: 2px;
      /* Button colour */
      --primary: #e53935;
      /* Highlight colour for called numbers */
      --highlight: #fff59d;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, sans-serif;
      background-color: #fafafa;
      overflow: hidden;
    }

    #app {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Left column with current number and controls */
    .left {
      width: var(--numCol);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 1rem;
      box-sizing: border-box;
      background-color: #ffffff;
      border-right: 1px solid #e0e0e0;
    }

    .current-number {
      font-size: 24vmin;
      line-height: 1;
      font-variant-numeric: tabular-nums;
      font-family: "Courier New", Courier, monospace;
      text-align: center;
      width: 100%;
      min-height: 1em;
      user-select: none;
    }

    .current-number.pop {
      animation: pop 0.4s ease-out;
    }

    @keyframes pop {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    #nextButton {
      margin-top: 1rem;
      padding: 1rem;
      font-size: 4vmin;
      background-color: var(--primary);
      color: #fff;
      border: none;
      border-radius: 8px;
      width: 80%;
      cursor: pointer;
      transition: transform 0.1s ease;
      user-select: none;
    }

    #nextButton:active:not(:disabled) {
      transform: scale(1.05);
    }

    #nextButton:disabled {
      background-color: #bdbdbd;
      cursor: default;
    }

    #count {
      margin-top: 0.5rem;
      font-size: 2.5vmin;
      user-select: none;
    }

    #resetButton {
      margin-top: 0.5rem;
      padding: 0.5rem;
      font-size: 2.5vmin;
      background-color: #9e9e9e;
      color: #fff;
      border: none;
      border-radius: 8px;
      width: 60%;
      cursor: pointer;
      transition: background-color 0.2s ease;
      user-select: none;
    }

    #resetButton:hover {
      background-color: #757575;
    }

    .right {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 1rem;
      box-sizing: border-box;
      overflow: hidden;
    }

    /* The 10×9 grid for numbers 1–90 */
    .grid {
      display: grid;
      grid-template-columns: repeat(9, var(--cell));
      grid-auto-rows: var(--cell);
      gap: var(--gap);
      justify-content: center;
      align-content: start;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    .grid .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: calc(var(--cell) * 0.4);
      background-color: #f5f5f5;
      border-radius: 4px;
      color: #212121;
      position: relative;
      user-select: none;
    }

    .grid .cell.called {
      background-color: var(--highlight);
      color: #000;
    }

    .grid .cell.current {
      border: 3px solid #fbc02d;
    }

    .grid .cell.pulse {
      animation: cellPulse 0.8s ease-out;
    }

    @keyframes cellPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.8);
      }
      70% {
        box-shadow: 0 0 15px 10px rgba(255, 235, 59, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(255, 235, 59, 0);
      }
    }

    /* Recent calls strip */
    .recent-calls {
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 0.5rem;
      justify-content: center;
      width: 100%;
      padding-bottom: 0.5rem;
    }

    .recent-calls .recent-cell {
      width: calc(var(--cell) * 0.8);
      height: calc(var(--cell) * 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #eeeeee;
      border-radius: 4px;
      font-size: calc(var(--cell) * 0.35);
      color: #212121;
      flex: 0 0 auto;
      user-select: none;
    }

    .recent-calls .recent-cell.current {
      background-color: var(--primary);
      color: #ffffff;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="left">
      <div class="current-number">--</div>
      <button id="nextButton">NEXT</button>
      <div id="count">Drawn: 0/90</div>
      <button id="resetButton">Reset</button>
    </div>
    <div class="right">
      <div class="grid" id="grid"></div>
      <div class="recent-calls" id="recentCalls"></div>
    </div>
  </div>

  <script>
    // Simple Fisher–Yates shuffle
    function shuffle(array) {
      let currentIndex = array.length;
      let randomIndex;
      while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
      return array;
    }

    // Global state object
    let state = { numbers: [], index: 0 };

    // Build the 1–90 grid
    function buildGrid() {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';
      for (let i = 1; i <= 90; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.num = i;
        cell.textContent = i;
        grid.appendChild(cell);
      }
    }

    // Update the display: current number, counts, grid classes and recent strip
    function updateDisplay() {
      const drawnCount = state.index;
      const currentNumber = state.numbers[state.index - 1] || '--';
      const currentElem = document.querySelector('.current-number');
      currentElem.textContent = currentNumber;
      const countElem = document.getElementById('count');
      countElem.textContent = 'Drawn: ' + drawnCount + '/90';
      // update grid cells
      const drawnSet = new Set(state.numbers.slice(0, state.index));
      document.querySelectorAll('.grid .cell').forEach(cell => {
        const num = parseInt(cell.dataset.num, 10);
        cell.classList.remove('called', 'current');
        if (drawnSet.has(num)) {
          cell.classList.add('called');
        }
        if (num === currentNumber) {
          cell.classList.add('current');
        }
      });
      // update recent calls strip
      const recentList = state.numbers.slice(Math.max(0, state.index - 10), state.index).reverse();
      const recentDiv = document.getElementById('recentCalls');
      recentDiv.innerHTML = '';
      recentList.forEach((num, idx) => {
        const rc = document.createElement('div');
        rc.className = 'recent-cell';
        rc.textContent = num;
        if (idx === 0) rc.classList.add('current');
        recentDiv.appendChild(rc);
      });
      // disable Next button when all numbers drawn
      const nextButton = document.getElementById('nextButton');
      nextButton.disabled = state.index >= state.numbers.length;
      // adjust cell size after recent calls update
      updateCellSize();
    }

    // Draw next number
    function drawNext() {
      if (state.index >= state.numbers.length) return;
      state.index++;
      // Save progress
      localStorage.setItem('bingoState', JSON.stringify(state));
      const currentNumber = state.numbers[state.index - 1];
      // Trigger big number animation
      const currentElem = document.querySelector('.current-number');
      currentElem.classList.remove('pop');
      // Force reflow to restart animation
      void currentElem.offsetWidth;
      currentElem.classList.add('pop');
      // Trigger cell pulse
      const targetCell = document.querySelector('.grid .cell[data-num="' + currentNumber + '"]');
      if (targetCell) {
        targetCell.classList.remove('pulse');
        void targetCell.offsetWidth;
        targetCell.classList.add('pulse');
      }
      updateDisplay();
    }

    // Reset the game with confirmation
    function resetGame() {
      if (!confirm('Reset game?')) return;
      // Generate new shuffled numbers
      const nums = [];
      for (let i = 1; i <= 90; i++) nums.push(i);
      shuffle(nums);
      state = { numbers: nums, index: 0 };
      localStorage.setItem('bingoState', JSON.stringify(state));
      updateDisplay();
    }

    // Compute and set cell size so grid fills available space
    function updateCellSize() {
      const right = document.querySelector('.right');
      const grid = document.getElementById('grid');
      const recent = document.getElementById('recentCalls');
      if (!right) return;
      const rightRect = right.getBoundingClientRect();
      const recentHeight = recent ? recent.getBoundingClientRect().height : 0;
      // space for grid height minus recent calls and a small margin
      const availableHeight = rightRect.height - recentHeight - 32;
      const cellHeight = availableHeight / 10;
      const cellWidth = rightRect.width / 9;
      const cellSize = Math.floor(Math.min(cellWidth, cellHeight));
      if (cellSize > 0) {
        document.documentElement.style.setProperty('--cell', cellSize + 'px');
      }
    }

    // Load state from localStorage or initialise a new game
    function initGame() {
      const stored = localStorage.getItem('bingoState');
      let numbers = [];
      let index = 0;
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed.numbers) && typeof parsed.index === 'number') {
            numbers = parsed.numbers;
            index = parsed.index;
          }
        } catch (e) {
          // ignore corrupted state
        }
      }
      if (!numbers.length) {
        for (let i = 1; i <= 90; i++) numbers.push(i);
        shuffle(numbers);
      }
      state = { numbers: numbers, index: index };
      buildGrid();
      updateDisplay();
    }

    // Attach event handlers
    window.addEventListener('load', () => {
      initGame();
      // NEXT button handler
      document.getElementById('nextButton').addEventListener('click', drawNext);
      // Reset button handler
      document.getElementById('resetButton').addEventListener('click', resetGame);
      // Spacebar triggers NEXT
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          drawNext();
        }
      });
      // Handle window resize
      window.addEventListener('resize', updateCellSize);
    });
  </script>
</body>
</html>
