<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
/>
<title>Bingo Caller</title>
<style>
  :root{
    /* Layout */
    --numColFractionOfHeight: 0.40; /* ≈40vmin */
    --gap: 10px;
    --panelRadius: 18px;

    /* Core UI colors (NEXT button red stays on-brand) */
    --primary: #ff3b3f;      /* lively red */
    --primaryDark: #d8262b;  /* press state */

    /* Dynamic per-game variables (set by JS) */
    --accent: #00c9b7;       /* outline pulse for current cell */
    --called: #ffd54f;       /* called-cell color (per selected) */
    --bgGlow1: #ff6a00;      /* gradient glow A (per selected) */
    --bgGlow2: #00e5ff;      /* gradient glow B (per selected) */
    --bgGlow3: #ffe066;      /* gradient glow C (per selected) */

    /* Neutral base */
    --bgDeepTop: #19143a;
    --bgDeepBottom: #0b0f24;
    --text: #ffffff;
    --subtle: #e9e7fb;
    --shadow: 0 10px 34px rgba(0,0,0,0.45);
  }

  /* Bold, punchy background driven by CSS variables */
  html, body {
    margin: 0;
    height: 100%;
    background:
      radial-gradient(1200px 900px at 15% 10%, var(--bgGlow1) 0%, color-mix(in oklab, var(--bgGlow1) 25%, transparent) 20%, transparent 40%),
      radial-gradient(1400px 900px at 85% 20%, var(--bgGlow2) 0%, color-mix(in oklab, var(--bgGlow2) 20%, transparent) 20%, transparent 45%),
      radial-gradient(1100px 600px at 50% 95%, var(--bgGlow3) 0%, color-mix(in oklab, var(--bgGlow3) 20%, transparent) 30%, transparent 55%),
      linear-gradient(180deg, var(--bgDeepTop), var(--bgDeepBottom));
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans";
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
  }

  .root {
    position: relative;
    display: grid;
    grid-template-columns: var(--leftWidthPx) 1fr;
    gap: var(--gap);
    padding: var(--gap);
    box-sizing: border-box;
    height: 100%;
    width: 100%;
  }

  .panel {
    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
    border-radius: var(--panelRadius);
    box-shadow: var(--shadow);
    border: 1px solid rgba(255,255,255,0.10);
  }

  /* LEFT: big number, BIG red NEXT, counter, reset */
  .leftCol {
    display: grid;
    grid-template-rows: 1fr auto auto auto;
    gap: var(--gap);
    min-width: 280px;
  }

  .bigNumberPanel {
    display: grid;
    place-items: center;
    position: relative;
    overflow: hidden;
    padding: 8px;
  }

  .bigNumber {
    font-variant-numeric: tabular-nums; /* fixed widths for 1/88/90 */
    font-weight: 900;
    line-height: 0.9;
    letter-spacing: -0.02em;
    text-shadow: 0 14px 30px rgba(0,0,0,0.55);
    white-space: pre;
    font-size: 24vmin; /* JS will override precisely */
    will-change: transform;
    transform-origin: center;
    user-select: none;
  }

  /* Idle breathe */
  @keyframes breathe {
    0% { transform: scale(1); }
    50% { transform: scale(1.02); }
    100% { transform: scale(1); }
  }
  .breathe { animation: breathe 5.2s ease-in-out infinite; }

  /* Pop on draw */
  @keyframes pop {
    0%   { transform: scale(1); }
    35%  { transform: scale(1.16); }
    100% { transform: scale(1); }
  }
  .pop { animation: pop 400ms cubic-bezier(.34,1.56,.64,1); }

  .rowPad { padding: 12px; }

  .counterRow {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
  }
  .counter { font-weight: 800; }
  .ver { opacity: .85; font-size: .9rem; }

  .btn {
    background: #1a1633;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 18px;
    color: var(--text);
    font-size: 1.35rem;
    font-weight: 900;
    padding: 18px 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: var(--shadow);
    user-select: none;
    touch-action: manipulation;
    position: relative;
  }
  .btn:active { transform: translateY(1px); }

  /* BIG red NEXT button */
  .btnNextBig {
    background: linear-gradient(180deg, var(--primary), var(--primaryDark));
    border-color: rgba(0,0,0,0.3);
    font-size: 2.3rem;
    padding: 30px 24px;
    letter-spacing: 0.02em;
  }
  .btn[disabled] { opacity: .6; cursor: not-allowed; }

  .cooldownOverlay {
    position: absolute; inset: 0; display: grid; place-items: center;
    background: rgba(0,0,0,0.25);
    border-radius: inherit; pointer-events: none;
  }
  .spinner {
    width: 30px; height: 30px;
    border: 3px solid rgba(255,255,255,0.25);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 900ms linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  .resetRow { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px; }
  .label { opacity:.9; font-weight:700; }

  /* RIGHT: grid and recent */
  .rightCol {
    display: grid;
    grid-template-rows: 1fr auto; /* grid area takes all remaining space */
    gap: var(--gap);
    min-width: 520px;
    min-height: 0; /* allow child to measure correctly */
  }

  .gridPanel {
    padding: var(--gap);
    box-sizing: border-box;
    position: relative;
    min-height: 0; /* critical for proper height measuring */
  }

  /* The grid gets sized ONLY by JS via --cellPx */
  .grid {
    display: grid;
    grid-template-rows: repeat(10, var(--cellPx));
    grid-template-columns: repeat(9, var(--cellPx));
    gap: 4px;
    justify-content: center;
    align-content: center;
    width: 100%;
    height: 100%;
  }

  .cell {
    display: grid; place-items: center;
    border-radius: 12px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.16);
    font-weight: 900;
    font-variant-numeric: tabular-nums;
    user-select: none;
  }
  .cell.called {
    background: var(--called); color: #1a1a1a; border-color: rgba(0,0,0,0.18);
  }
  .cell.current {
    outline: 2px solid var(--accent);
    box-shadow:
      0 0 0 5px color-mix(in oklab, var(--accent) 18%, transparent),
      0 0 36px 6px color-mix(in oklab, var(--accent) 35%, transparent) inset,
      0 8px 28px color-mix(in oklab, var(--accent) 22%, transparent);
    animation: cellPulse 1200ms ease-in-out infinite;
  }
  @keyframes cellPulse {
    0% { box-shadow:
      0 0 0 5px color-mix(in oklab, var(--accent) 16%, transparent),
      0 0 18px 2px color-mix(in oklab, var(--accent) 22%, transparent) inset; }
    50% { box-shadow:
      0 0 0 7px color-mix(in oklab, var(--accent) 24%, transparent),
      0 0 40px 8px color-mix(in oklab, var(--accent) 38%, transparent) inset; }
    100% { box-shadow:
      0 0 0 5px color-mix(in oklab, var(--accent) 16%, transparent),
      0 0 18px 2px color-mix(in oklab, var(--accent) 22%, transparent) inset; }
  }

  .recentPanel {
    padding: 10px;
    display: grid;
    grid-auto-flow: column;
    gap: 8px;
    overflow-x: auto;
    overscroll-behavior-x: contain;
  }
  .chip {
    min-width: 44px; padding: 8px 12px; border-radius: 999px;
    background: rgba(255,255,255,0.12);
    border: 1px solid rgba(255,255,255,0.2);
    text-align: center; font-weight: 900; font-variant-numeric: tabular-nums;
    user-select: none; white-space: nowrap;
    color: var(--text);
  }
  .chip.newest {
    background: color-mix(in oklab, var(--accent) 35%, transparent);
    border-color: color-mix(in oklab, var(--accent) 65%, transparent);
    color: #061313;
  }

  @media (orientation: portrait) {
    .root {
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
    }
    .rightCol { min-width: 0; }
  }

  .toolsRow {
    position: absolute; top: 8px; right: 8px; display: flex; gap: 8px; z-index: 10;
  }
  .tinyBtn {
    background: rgba(255,255,255,0.12);
    border: 1px solid rgba(255,255,255,0.22);
    color: var(--text);
    padding: 6px 10px; border-radius: 10px; font-size: 12px; cursor: pointer;
  }
  .tinyBtn:active { transform: translateY(1px); }

  .sr-live { position:absolute; left:-10000px; width:1px; height:1px; overflow:hidden; }

  /* Confetti overlay canvas */
  .fx {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 999;
  }

  /* -------- Reset Color Modal -------- */
  .modal.hidden { display: none; }

  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(4px);
    display: grid;
    place-items: center;
    z-index: 1000;
  }

  .modalBox {
    background: #1a1633;
    border-radius: 18px;
    padding: 24px;
    width: min(92%, 520px);
    box-shadow: 0 0 40px rgba(0,0,0,0.45);
    border: 2px solid rgba(255,255,255,0.18);
    text-align: center;
    color: var(--text);
  }

  .modalTitle {
    font-size: 1.6rem;
    font-weight: 900;
    margin-bottom: 8px;
  }

  .modalText {
    opacity: 0.9;
    margin-bottom: 18px;
  }

  .colorGrid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
    margin-top: 8px;
    margin-bottom: 14px;
  }

  .colorBtn {
    display: grid;
    place-items: center;
    padding: 18px 12px;
    border-radius: 14px;
    border: 2px solid rgba(255,255,255,0.18);
    color: #0b0b0b;
    font-weight: 900;
    cursor: pointer;
    user-select: none;
    box-shadow: var(--shadow);
  }
  .colorBtn:active { transform: translateY(1px); }

  .modalFooter {
    margin-top: 8px;
    display: flex;
    justify-content: center;
  }
  .modalNote {
    opacity: 0.75;
    font-size: 0.95rem;
  }
</style>
</head>
<body>
  <div class="root" id="app" role="application" aria-label="Bingo Caller">
    <div class="toolsRow">
      <button class="tinyBtn" id="btnFullscreen" title="Fullscreen">Fullscreen</button>
      <button class="tinyBtn" id="btnWake" title="Stay awake">Stay Awake</button>
    </div>

    <!-- LEFT -->
    <div class="leftCol">
      <div class="panel bigNumberPanel" aria-live="polite" aria-atomic="true">
        <div id="bigNumber" class="bigNumber breathe" role="status" aria-label="Current number">—</div>
      </div>

      <!-- BIG red NEXT button -->
      <button id="btnNext" class="panel btn btnNextBig" aria-label="Next number">NEXT</button>

      <div class="panel rowPad counterRow">
        <div class="counter" id="counter">Drawn: 0 / 90</div>
        <div class="ver">v1.3.0</div>
      </div>

      <div class="panel rowPad resetRow">
        <div class="label">Newest:</div>
        <div id="newest" style="text-align:right;font-weight:900;font-variant-numeric:tabular-nums">—</div>
        <button id="btnReset" class="btn" aria-label="Reset and reshuffle">RESET</button>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="rightCol">
      <div class="panel gridPanel">
        <div id="grid" class="grid" aria-label="Numbers grid"></div>
      </div>

      <div class="panel recentPanel" id="recent" aria-label="Recent numbers strip"></div>
    </div>
  </div>

  <!-- Live region for screen readers -->
  <div id="live" class="sr-live" aria-live="assertive" aria-atomic="true"></div>

  <!-- Confetti canvas -->
  <canvas id="fx" class="fx"></canvas>

  <!-- Reset Color Modal -->
  <div id="resetModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="resetTitle">
    <div class="modalBox">
      <div id="resetTitle" class="modalTitle">Start new game</div>
      <div class="modalText">Choose a highlight colour for called numbers (also sets the background theme):</div>

      <div class="colorGrid">
        <div class="colorBtn" data-color="Yellow" data-hex="#ffd54f" style="background:#ffd54f;">Yellow</div>
        <div class="colorBtn" data-color="Red"    data-hex="#ff6a6a" style="background:#ff6a6a;">Red</div>
        <div class="colorBtn" data-color="Blue"   data-hex="#80d8ff" style="background:#80d8ff;">Blue</div>
        <div class="colorBtn" data-color="Brown"  data-hex="#c49a6c" style="background:#c49a6c;">Brown</div>
        <div class="colorBtn" data-color="Pink"   data-hex="#ff99cc" style="background:#ff99cc;">Pink</div>
        <div class="colorBtn" data-color="Green"  data-hex="#a5d6a7" style="background:#a5d6a7;">Green</div>
      </div>

      <div class="modalFooter">
        <div class="modalNote">You can change colour on every reset.</div>
      </div>
    </div>
  </div>

<script>
(function(){
  "use strict";

  /********************
   * CONFIG
   ********************/
  const NUMBERS = 90, ROWS = 10, COLS = 9, COOLDOWN_MS = 1000;
  const LEFT_FRACTION = 0.40;
  const STORAGE_KEY = 'bingo_state_v3';     // bumped for theme per color
  const SNAPSHOT_KEY = 'bingo_snapshot_v3';

  const els = {
    grid: document.getElementById('grid'),
    bigNumber: document.getElementById('bigNumber'),
    counter: document.getElementById('counter'),
    newest: document.getElementById('newest'),
    recent: document.getElementById('recent'),
    btnNext: document.getElementById('btnNext'),
    btnReset: document.getElementById('btnReset'),
    btnFullscreen: document.getElementById('btnFullscreen'),
    btnWake: document.getElementById('btnWake'),
    live: document.getElementById('live'),
    fx: document.getElementById('fx'),
    resetModal: document.getElementById('resetModal')
  };

  let coolingDown = false;
  let wakeLock = null;

  // Game state
  let state = {
    numbers: [],
    index: -1,
    seed: 0,
    updatedAt: 0,
    calledColorName: 'Yellow',
    calledColorHex: '#ffd54f'
  };

  /********************
   * THEME MAP
   * For each selected color, set:
   *  - called (cell bg)
   *  - accent (outline glow)
   *  - bgGlow1/2/3 (background gradients)
   ********************/
  const THEMES = {
    Yellow: {
      called: '#ffd54f',
      accent: '#00c9b7',
      bgGlow1: '#ffb300', bgGlow2: '#00d1ff', bgGlow3: '#ffe066'
    },
    Red: {
      called: '#ff6a6a',
      accent: '#00e5ff',
      bgGlow1: '#ff3b3f', bgGlow2: '#ff9f1c', bgGlow3: '#ffe066'
    },
    Blue: {
      called: '#80d8ff',
      accent: '#ff9f1c',
      bgGlow1: '#0091ea', bgGlow2: '#80d8ff', bgGlow3: '#00e5ff'
    },
    Brown: {
      called: '#c49a6c',
      accent: '#00c9b7',
      bgGlow1: '#8d6e63', bgGlow2: '#c49a6c', bgGlow3: '#a1887f'
    },
    Pink: {
      called: '#ff99cc',
      accent: '#a3ff12',
      bgGlow1: '#ff5fa2', bgGlow2: '#ff99cc', bgGlow3: '#ffc2e2'
    },
    Green: {
      called: '#a5d6a7',
      accent: '#c44dff',
      bgGlow1: '#00c853', bgGlow2: '#a5d6a7', bgGlow3: '#66ffa6'
    }
  };

  function applyThemeByName(name, calledHex) {
    const t = THEMES[name] || THEMES['Yellow'];
    // allow custom hex override for called
    document.documentElement.style.setProperty('--called', calledHex || t.called);
    document.documentElement.style.setProperty('--accent', t.accent);
    document.documentElement.style.setProperty('--bgGlow1', t.bgGlow1);
    document.documentElement.style.setProperty('--bgGlow2', t.bgGlow2);
    document.documentElement.style.setProperty('--bgGlow3', t.bgGlow3);
  }

  /********************
   * UTILITIES
   ********************/
  const nowTs = () => Date.now();

  function seededRandom(seed) {
    // Simple mulberry32 PRNG for reproducibility
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }

  function fisherYatesShuffle(arr, rand) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(rand() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function saveState() {
    state.updatedAt = nowTs();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    // also snapshot a human-friendly JSON
    localStorage.setItem(SNAPSHOT_KEY, JSON.stringify({
      sequence: state.numbers,
      index: state.index,
      seed: state.seed,
      updatedAt: state.updatedAt,
      calledColorName: state.calledColorName,
      calledColorHex: state.calledColorHex,
      drawn: state.index + 1,
      remaining: Math.max(0, NUMBERS - (state.index + 1))
    }, null, 2));
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const obj = JSON.parse(raw);
      if (!Array.isArray(obj.numbers) || obj.numbers.length !== NUMBERS) return false;
      if (typeof obj.index !== 'number' || typeof obj.seed !== 'number') return false;
      state = Object.assign({
        calledColorName: 'Yellow',
        calledColorHex: '#ffd54f'
      }, obj);
      applyThemeByName(state.calledColorName, state.calledColorHex);
      return true;
    } catch {
      return false;
    }
  }

  function performResetWithColor(name, hex){
    state.calledColorName = name;
    state.calledColorHex = hex;
    applyThemeByName(name, hex);

    state.seed = Math.floor(Math.random() * 0xFFFFFFFF);
    const rand = seededRandom(state.seed);
    state.numbers = Array.from({length: NUMBERS}, (_, i) => i + 1);
    fisherYatesShuffle(state.numbers, rand);
    state.index = -1;
    saveState();
    renderAll();
    announce(`New ${name} game. Ready.`);
  }

  /********************
   * LAYOUT SIZING
   ********************/
  function setLeftWidthFromHeight() {
    const h = window.innerHeight;
    const leftPx = Math.floor(h * LEFT_FRACTION);
    document.documentElement.style.setProperty('--leftWidthPx', leftPx + 'px');
  }

  function exactInnerBox(el){
    const st = getComputedStyle(el);
    const padX = parseFloat(st.paddingLeft)+parseFloat(st.paddingRight);
    const padY = parseFloat(st.paddingTop)+parseFloat(st.paddingBottom);
    const bW = el.clientWidth - padX;
    const bH = el.clientHeight - padY;
    return {w: Math.max(0,bW), h: Math.max(0,bH)};
  }

  function sizeGridCells() {
    const gridPanel = document.querySelector('.gridPanel');
    const {w: availW, h: availH} = exactInnerBox(gridPanel);

    const gap = 4;
    const cellW = Math.floor((availW - gap * (COLS - 1)) / COLS);
    const cellH = Math.floor((availH - gap * (ROWS - 1)) / ROWS);
    const cell = Math.max(22, Math.min(cellW, cellH));
    document.documentElement.style.setProperty('--cellPx', cell + 'px');
  }

  // Width+height aware big-number fit (never clips)
  function fitBigNumber(){
    const panel = document.querySelector('.bigNumberPanel');
    const { w: availW, h: availH } = exactInnerBox(panel);

    // Use widest typical sample (“88”) so we always fit
    const sample = '88';

    const el = els.bigNumber;
    const oldText = el.textContent;

    el.textContent = sample;
    el.style.fontSize = '100px';
    el.style.visibility = 'hidden';
    void el.offsetWidth;

    const measuredWidthAt100 = el.clientWidth || el.getBoundingClientRect().width || 200;

    const widthLimited = Math.floor((availW * 0.90) * (100 / measuredWidthAt100));
    const heightLimited = Math.floor(availH * 0.72);

    const finalPx = Math.max(28, Math.min(widthLimited, heightLimited));

    el.style.fontSize = finalPx + 'px';
    el.style.visibility = '';
    el.textContent = oldText;
  }

  function reflow() {
    setLeftWidthFromHeight();
    sizeGridCells();
    fitBigNumber();
  }

  /********************
   * RENDER
   ********************/
  function currentNumber() {
    return state.index >= 0 ? state.numbers[state.index] : null;
  }

  function recentList(limit = 10) {
    const start = Math.max(0, state.index - limit + 1);
    return state.numbers.slice(start, state.index + 1).reverse();
  }

  function isCalled(n) {
    return state.index >= 0 && state.numbers.indexOf(n) <= state.index;
  }

  function renderGrid() {
    if (!els.grid.hasChildNodes()) {
      const frag = document.createDocumentFragment();
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const n = r * COLS + c + 1;
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.textContent = n.toString();
          cell.id = `cell-${n}`;
          frag.appendChild(cell);
        }
      }
      els.grid.appendChild(frag);
    }

    const cur = currentNumber();
    for (let n = 1; n <= NUMBERS; n++) {
      const cell = document.getElementById(`cell-${n}`);
      cell.classList.toggle('called', isCalled(n));
      cell.classList.toggle('current', cur === n);
    }
  }

  function renderRecent() {
    const list = recentList(10);
    els.recent.replaceChildren();
    list.forEach((n, i) => {
      const chip = document.createElement('div');
      chip.className = 'chip' + (i === 0 ? ' newest' : '');
      chip.textContent = n.toString();
      els.recent.appendChild(chip);
    });

    els.newest.textContent = list.length ? list[0].toString() : '—';
  }

  function renderCounter() {
    els.counter.textContent = `Drawn: ${state.index + 1} / ${NUMBERS}`;
  }

  function renderBigNumber(pop = false) {
    const n = currentNumber();
    const text = n != null ? n.toString().padStart(2, ' ') : '—';
    els.bigNumber.textContent = text;

    if (pop) {
      els.bigNumber.classList.remove('pop');
      void els.bigNumber.offsetWidth;
      els.bigNumber.classList.add('pop');
    }
  }

  function renderAll(pop = false) {
    renderGrid();
    renderRecent();
    renderCounter();
    renderBigNumber(pop);
  }

  /********************
   * CONFETTI ENGINE (medium burst)
   ********************/
  const fxc = els.fx.getContext('2d');
  let fxWidth = 0, fxHeight = 0, dpr = Math.max(1, window.devicePixelRatio || 1);
  let confetti = [];
  let fxAnimating = false;

  const CONFETTI_COLORS = ['#ff3b3f','#ff8a00','#ffd54f','#00c9b7','#00ffa6','#c44dff','#ffffff'];
  const TWO_PI = Math.PI * 2;

  function resizeFX(){
    fxWidth = Math.floor(window.innerWidth * dpr);
    fxHeight = Math.floor(window.innerHeight * dpr);
    els.fx.width = fxWidth;
    els.fx.height = fxHeight;
    els.fx.style.width = (fxWidth/dpr) + 'px';
    els.fx.style.height = (fxHeight/dpr) + 'px';
    fxc.setTransform(1,0,0,1,0,0);
    fxc.scale(dpr, dpr);
  }
  resizeFX();
  window.addEventListener('resize', () => { dpr = Math.max(1, window.devicePixelRatio||1); resizeFX(); });

  function spawnConfettiBurst(originX, originY, count=140){
    const baseSpeed = 600;  // px/s
    for(let i=0;i<count;i++){
      const angle = Math.random()*Math.PI - Math.PI/2; // left/up to right/up
      const speed = baseSpeed*(0.45 + Math.random()*0.8);
      const vx = Math.cos(angle)*speed;
      const vy = Math.sin(angle)*speed - (250 + Math.random()*200); // initial upward impulse

      confetti.push({
        x: originX, y: originY,
        vx, vy,
        ay: 900 + Math.random()*400, // gravity
        size: 6 + Math.random()*10,
        rot: Math.random()*TWO_PI,
        rotSpeed: (Math.random()<0.5?-1:1)*(2 + Math.random()*6),
        color: CONFETTI_COLORS[(Math.random()*CONFETTI_COLORS.length)|0],
        shape: Math.random()<0.75 ? 'rect' : 'triangle',
        life: 1500 + Math.random()*700, // ms
        born: performance.now()
      });
    }
    if(!fxAnimating) {
      fxAnimating = true;
      requestAnimationFrame(stepConfetti);
    }
  }

  function stepConfetti(ts){
    fxc.clearRect(0,0,fxWidth/dpr,fxHeight/dpr);
    const now = ts;
    confetti = confetti.filter(p => (now - p.born) < p.life);
    for(const p of confetti){
      const dt = 16/1000; // ~60fps step approximation
      p.vy += p.ay*dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.rot += p.rotSpeed*dt;

      fxc.save();
      fxc.translate(p.x, p.y);
      fxc.rotate(p.rot);
      fxc.fillStyle = p.color;

      if(p.shape==='rect'){
        fxc.fillRect(-p.size*0.5, -p.size*0.5, p.size, p.size*0.6);
      } else {
        fxc.beginPath();
        fxc.moveTo(0, -p.size*0.6);
        fxc.lineTo(p.size*0.6, p.size*0.6);
        fxc.lineTo(-p.size*0.6, p.size*0.6);
        fxc.closePath();
        fxc.fill();
      }
      fxc.restore();
    }

    if(confetti.length>0) requestAnimationFrame(stepConfetti);
    else fxAnimating = false;
  }

  function confettiFromBigNumber(){
    const el = els.bigNumber;
    const rect = el.getBoundingClientRect();
    const x = rect.left + rect.width/2;
    const y = rect.top + rect.height*0.4; // a bit above center
    spawnConfettiBurst(x, y, 150); // medium
  }

  /********************
   * INTERACTIONS
   ********************/
  function announce(text) {
    els.live.textContent = text;
    try {
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1.0;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    } catch {}
  }

  function haptics() {
    if ('vibrate' in navigator) {
      navigator.vibrate(20);
    }
  }

  function startCooldown() {
    coolingDown = true;
    els.btnNext.setAttribute('disabled', 'true');

    let overlay = els.btnNext.querySelector('.cooldownOverlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.className = 'cooldownOverlay';
      overlay.innerHTML = '<div class="spinner" role="progressbar" aria-label="Cooling down"></div>';
      els.btnNext.appendChild(overlay);
    }
    overlay.style.display = 'grid';

    setTimeout(() => {
      coolingDown = false;
      els.btnNext.removeAttribute('disabled');
      if (overlay) overlay.style.display = 'none';
    }, COOLDOWN_MS);
  }

  function onNext() {
    if (coolingDown) return;
    if (state.index >= NUMBERS - 1) {
      announce("All numbers drawn.");
      return;
    }
    state.index += 1;
    saveState();
    renderAll(true);
    startCooldown();
    haptics();
    confettiFromBigNumber();
    const n = currentNumber();
    if (typeof n === 'number') {
      announce(`Number ${n}`);
    }
  }

  // Show custom modal instead of confirm()
  function onReset() {
    els.resetModal.classList.remove('hidden');
  }

  // Wire up colour modal buttons
  function setupResetModal(){
    els.resetModal.addEventListener('click', (e)=>{
      // Clicking outside the box closes modal without resetting
      if (e.target === els.resetModal) {
        els.resetModal.classList.add('hidden');
      }
    });

    const btns = els.resetModal.querySelectorAll('.colorBtn');
    btns.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const name = btn.getAttribute('data-color');
        const hex = btn.getAttribute('data-hex');
        els.resetModal.classList.add('hidden');
        performResetWithColor(name, hex);
      });
    });
  }

  // Keyboard: spacebar triggers NEXT
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      onNext();
    }
  });

  // Fullscreen helpers
  async function requestFullscreen() {
    const docEl = document.documentElement;
    if (document.fullscreenElement) {
      await document.exitFullscreen();
    } else {
      await docEl.requestFullscreen({ navigationUI: "hide" }).catch(()=>{});
    }
  }

  // Wake lock
  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => { /* released */ });
      } else {
        // not supported
      }
    } catch (err) {
      console.warn('WakeLock error:', err);
    }
  }

  /********************
   * INIT
   ********************/
  function reflowAndRender(){
    renderAll(false);
    reflow();
  }

  function init() {
    els.btnNext.addEventListener('click', onNext);
    els.btnReset.addEventListener('click', onReset);
    els.btnFullscreen.addEventListener('click', requestFullscreen);
    els.btnWake.addEventListener('click', requestWakeLock);

    setupResetModal();

    const ro = new ResizeObserver(()=>{ reflow(); });
    ro.observe(document.body);

    window.addEventListener('orientationchange', ()=>{ setTimeout(reflow, 120); });

    if (!loadState()) {
      // First run: open modal to pick a colour, theme updates after selection
      els.resetModal.classList.remove('hidden');
      // Apply default theme so background looks good even before first pick
      applyThemeByName(state.calledColorName, state.calledColorHex);
    } else {
      reflowAndRender();
    }

    // Attempt wake lock automatically (non-fatal)
    requestWakeLock();
  }

  init();
})();
</script>
</body>
</html>
